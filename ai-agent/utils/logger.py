"""
JSONL logging utility for AI agent interactions and decisions.
"""

import json
import logging
import os
from datetime import datetime
from typing import Dict, Any, Optional


class JSONLLogger:
    """Logger that writes structured data to JSONL format."""
    
    def __init__(self, log_file: str = "agent_interactions.jsonl"):
        """
        Initialize the JSONL logger.
        
        Args:
            log_file: Path to the JSONL log file
        """
        self.log_file = log_file
        self.setup_logging()
    
    def setup_logging(self):
        """Set up standard Python logging."""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
    
    def log_interaction(
        self,
        interaction_type: str,
        user_input: Dict[str, Any],
        agent_response: Dict[str, Any],
        memories_retrieved: Optional[list] = None,
        reasoning_process: Optional[Dict[str, Any]] = None,
        execution_time: Optional[float] = None
    ):
        """
        Log a complete interaction between user and agent.
        
        Args:
            interaction_type: Type of interaction (e.g., 'query', 'task', 'conversation')
            user_input: The input received from the user
            agent_response: The response generated by the agent
            memories_retrieved: List of memories retrieved from Pinecone
            reasoning_process: Details about the reasoning process
            execution_time: Time taken to process the interaction
        """
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "interaction_type": interaction_type,
            "user_input": user_input,
            "agent_response": agent_response,
            "memories_retrieved": memories_retrieved or [],
            "reasoning_process": reasoning_process or {},
            "execution_time_seconds": execution_time,
            "session_id": self._get_session_id()
        }
        
        self._write_jsonl(log_entry)
        self.logger.info(f"Logged {interaction_type} interaction")
    
    def log_decision(
        self,
        decision_type: str,
        context: Dict[str, Any],
        decision: str,
        confidence: Optional[float] = None,
        alternatives: Optional[list] = None
    ):
        """
        Log an agent decision.
        
        Args:
            decision_type: Type of decision made
            context: Context that influenced the decision
            decision: The actual decision made
            confidence: Confidence score for the decision
            alternatives: Alternative options considered
        """
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event_type": "decision",
            "decision_type": decision_type,
            "context": context,
            "decision": decision,
            "confidence": confidence,
            "alternatives": alternatives or [],
            "session_id": self._get_session_id()
        }
        
        self._write_jsonl(log_entry)
        self.logger.info(f"Logged decision: {decision_type}")
    
    def log_memory_operation(
        self,
        operation: str,
        details: Dict[str, Any],
        success: bool = True,
        error_message: Optional[str] = None
    ):
        """
        Log memory operations (store, retrieve, update).
        
        Args:
            operation: Type of memory operation
            details: Details about the operation
            success: Whether the operation succeeded
            error_message: Error message if operation failed
        """
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event_type": "memory_operation",
            "operation": operation,
            "details": details,
            "success": success,
            "error_message": error_message,
            "session_id": self._get_session_id()
        }
        
        self._write_jsonl(log_entry)
        self.logger.info(f"Logged memory operation: {operation}")
    
    def _write_jsonl(self, data: Dict[str, Any]):
        """Write a single JSON line to the log file."""
        try:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(json.dumps(data, ensure_ascii=False) + '\n')
        except Exception as e:
            self.logger.error(f"Failed to write to JSONL log: {e}")
    
    def _get_session_id(self) -> str:
        """Get or create a session ID for this process."""
        if not hasattr(self, '_session_id'):
            self._session_id = f"session_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}"
        return self._session_id
    
    def read_recent_logs(self, limit: int = 100) -> list:
        """
        Read recent log entries.
        
        Args:
            limit: Maximum number of entries to return
            
        Returns:
            List of recent log entries
        """
        if not os.path.exists(self.log_file):
            return []
        
        try:
            with open(self.log_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                recent_lines = lines[-limit:] if len(lines) > limit else lines
                return [json.loads(line.strip()) for line in recent_lines if line.strip()]
        except Exception as e:
            self.logger.error(f"Failed to read log entries: {e}")
            return []